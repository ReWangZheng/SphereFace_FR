import tensorflow as tffrom layer import *from loss import *from dataset import LFWHelperfrom util import *from tqdm import tqdmimport sysimport cv2from tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets("/home/regan/code/deeplearn/SphereFace/MNIST_data/", one_hot=False, reshape=False)class SphereFace:    def __init__(self,batch = 100,is_train=True,num_cls=10,save_path='../models/'):        self.graph = tf.Graph()        self.input_size = [28,28,1]        self.embedding_dim = 2        self.batch = batch        self.target_step = 100        self.target_epoch = 400        with self.graph.as_default():            self.log = SummaryUitil(scope="SphereFace")            self.helper = LFWHelper(batch=self.batch)            self.inputs = tf.placeholder(dtype=tf.float32,                                         shape=[self.batch, self.input_size[0],                                                self.input_size[1], self.input_size[-1]])            self.target = tf.placeholder(dtype=tf.int64, shape=[self.batch])            with tf.variable_scope("sphereFace"):                # layer 1                self.out_1 = add_conv(self.inputs,[3,3,self.input_size[-1],64],'conv_layer_1',prelu,s=2)                # layer 2                self.out_2 = add_conv(self.out_1,[3,3,64,64],'conv_layer_2',prelu,s=1)                # layer 3                self.out_3 = add_conv(self.out_2,[3,3,64,128],'conv_layer_3',prelu,s=2)                # layer 4                self.out_4 = add_conv(self.out_3,[3,3,128,128],'conv_layer_4',prelu,s=1)                # FC                self.fc= add_flatten(self.out_4,"fc4")                self.embedding = add_dense(self.fc,self.embedding_dim,'dense_layer5')                if is_train:                    self.prob, self.loss = Asoftmax(self.embedding,self.target,0.5,10)                    self.global_step = tf.Variable(0, trainable=False)                    self.add_step_op = tf.assign_add(self.global_step, tf.constant(1))                    self.global_epoch = tf.Variable(1,trainable=False)                    self.add_epoch_op = tf.assign_add(self.global_epoch,tf.constant(1))                    decay_lr = tf.train.exponential_decay(0.01,self.global_step, 500, 0.9)                    self.train_opt = tf.train.AdamOptimizer(decay_lr).minimize(self.loss)                    self.accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(self.logits,axis=1),self.target),dtype=tf.float32))            self.sess = tf.Session()            self.saver = ModelHelper(save_path, self.sess)    def extract_feature(self,image,resize=False):        x_in = np.empty(shape=[len(image),*self.input_size])        if resize:            for i in range(0, len(image)):                x_in[i] = cv2.resize(image[i], dsize=(self.input_size[0], self.input_size[1]))        else:            x_in = image        self.batch = len(image)        with self.graph.as_default():            self.saver.reload()            return self.sess.run(self.embedding,feed_dict={self.inputs:x_in})    def train(self):        with self.graph.as_default():            self.sess.run(tf.global_variables_initializer())            self.saver.reload()            init_op, data_train = self.helper.get_iterator()            self.sess.run(init_op)            current_epoch = self.sess.run(self.global_epoch)            for epoch in range(current_epoch,self.target_epoch):                for step in tqdm(range(0,self.target_step),file=sys.stdout,unit=' step'):                    # batch_images, batch_labels = self.sess.run(data_train)                    batch_images, batch_labels = mnist.train.next_batch(self.batch)                    self.sess.run([self.train_opt,self.add_step_op], feed_dict={self.inputs: batch_images, self.target: batch_labels})                epoch,step,loss_v,acc= self.sess.run([self.add_epoch_op,self.global_step,self.loss,self.accuracy],feed_dict={self.inputs: batch_images, self.target: batch_labels})                print("epoch:{}---------------step:{} loss:{:.4f}  accuracy:{:.3f} \n".format(epoch,step,loss_v,acc))                self.saver.save(0)def train_model():    face_model = SphereFace()    face_model.train()def test_MNIST():    face_model = SphereFace(is_train=False,batch=1000)    x_test,y_test = mnist.test.next_batch(1000)    feature = face_model.extract_feature(x_test)    for i in range(0,10):        plt.scatter(feature[y_test==i][:,0],y=feature[y_test==i][:,1])    plt.show()if __name__ == '__main__':    test_MNIST()